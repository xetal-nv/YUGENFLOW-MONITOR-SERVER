

array Sensor
    var Transaction    //-2 -1 0 ... +2 etc
    var timestamp      //time of the transaction

array Gate OK
    array sensor    //the first element is the sensor that will see as first the person if entering and as last if going out the second element the opposite  (index)


InternalMemory
    array SensorMemory   //same size of Sensor
        var Transaction  //we save here the previous transaction to avoid double counting 
        var timestamp
    
    array SensorTransactionSum //contain transactions not yet assigned per sensor


Init

    0 everything 
    fill the Gate array with the correct data


Update
    uint8_t results = 0

    for(uint8_t i=0;i<Sensor.size();i++){
        if(SensorMemory[i].timestamp != Sensor[i].timestamp || SensorMemory[i].transaction != Sensor[i].transaction){  //new transaction detected
            SensorMemory[i].timestamp = Sensor[i].timestamp; //save new transaction
            SensorMemory[i].transaction = Sensor[i].transaction; //save new transaction
            SensorTransactionSum[i]+=Sensor[i].transaction;
        }
    } 
    
    for(uint8_t i=0;i<Gate.size();i++){
         if( SensorTransactionSum[Gate[i].sensor[0]] > 0 && SensorTransactionSum[Gate[i].sensor[1]] > 0){ //ingresso
             uint16_t temp;
             temp=abs(SensorTransactionSum[Gate[i].sensor[0]]-SensorTransactionSum[Gate[i].sensor[1]];
             results += temp;
             SensorTransactionSum[Gate[i].sensor[0]]-=temp;
             SensorTransactionSum[Gate[i].sensor[1]]-=temp;
         }else  if( SensorTransactionSum[Gate[i].sensor[0]] < 0 && SensorTransactionSum[Gate[i].sensor[1]] < 0){ //uscita
             uint16_t temp;
             temp=abs(SensorTransactionSum[Gate[i].sensor[0]]-SensorTransactionSum[Gate[i].sensor[1]];
             results -= temp;
             SensorTransactionSum[Gate[i].sensor[0]]+=temp;
             SensorTransactionSum[Gate[i].sensor[1]]+=temp;
         }     
    }
    

    for(uint8_t i=0;i<Gate.size();i++){
         if( SensorTransactionSum[Gate[i].sensor[0]] < 0){ //uscita not detected by sensor 1, max one error
             SensorTransactionSum[Gate[i].sensor[0]]=0;
             results--;
         } if( SensorTransactionSum[Gate[i].sensor[1]] > 0){ //ingresso not detected by sensor 0, max one error
             SensorTransactionSum[Gate[i].sensor[1]]=0;
             results++;
         } 
    }
    
    
    
    
    
